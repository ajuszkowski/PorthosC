package mousquetaires.memorymodels.old;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.microsoft.z3.*;

import mousquetaires.execution.Programme;
import mousquetaires.execution.events.old.Event;
import mousquetaires.execution.events.old.Init;
import mousquetaires.execution.events.old.Load;
import mousquetaires.execution.events.old.Local;
import mousquetaires.execution.memory.MemoryLocation;
import mousquetaires.execution.events.old.MemEvent;
import mousquetaires.execution.events.old.Register;
import mousquetaires.execution.events.old.Store;
import mousquetaires.utils.Utils;
import static mousquetaires.utils.Utils.lastValueLoc;
import static mousquetaires.utils.Utils.lastValueReg;

public class Encodings {

    public static BoolExpr satComp(String processName, String r1, String r2, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            for(Event e2 : events) {
                BoolExpr orClause = ctx.mkFalse();
                for(Event e3 : events) {
                    orClause = ctx.mkOr(orClause, ctx.mkAnd(Utils.edge(r1, e1, e3, ctx), Utils.edge(r2, e3, e2, ctx)));
                }
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(processName, e1, e2, ctx), orClause));
            }
        }
        return enc;
    }

    public static BoolExpr satComp(String r1, String r2, Set<Event> events, Context ctx) {
        String processName = String.format("(%s;%s)", r1, r2);
        return satComp(processName, r1, r2, events, ctx);
    }

    public static BoolExpr satEmpty(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkNot(Utils.edge(processName, e1, e2, ctx)));
            }
        }
        return enc;
    }

    public static BoolExpr satUnion(String processName, String r1, String r2, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(processName, e1, e2, ctx), ctx.mkOr(Utils.edge(r1, e1, e2, ctx), Utils.edge(r2, e1, e2, ctx))));
            }
        }
        return enc;
    }

    public static BoolExpr satUnion(String r1, String r2, Set<Event> events, Context ctx) {
        String processName = String.format("(%s+%s)", r1, r2);
        return satUnion(processName, r1, r2, events, ctx);
    }

    public static BoolExpr satIntersection(String processName, String r1, String r2, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(processName, e1, e2, ctx), ctx.mkAnd(Utils.edge(r1, e1, e2, ctx), Utils.edge(r2, e1, e2, ctx))));
            }
        }
        return enc;
    }

    public static BoolExpr satIntersection(String r1, String r2, Set<Event> events, Context ctx) {
        String processName = String.format("(%s&%s)", r1, r2);
        return satIntersection(processName, r1, r2, events, ctx);
    }

    public static BoolExpr satMinus(String processName, String r1, String r2, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(processName, e1, e2, ctx), ctx.mkAnd(Utils.edge(r1, e1, e2, ctx), ctx.mkNot(Utils.edge(r2, e1, e2, ctx)))));
            }
        }
        return enc;
    }

    public static BoolExpr satMinus(String r1, String r2, Set<Event> events, Context ctx) {
        String processName = String.format("(%s\\%s)", r1, r2);
        return satMinus(processName, r1, r2, events, ctx);
    }

    public static BoolExpr satTO(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            enc = ctx.mkAnd(enc, ctx.mkImplies(e1.executes(ctx), ctx.mkGt(Utils.intVar(processName, e1, ctx), ctx.mkInt(0))));
            enc = ctx.mkAnd(enc, ctx.mkImplies(e1.executes(ctx), ctx.mkLe(Utils.intVar(processName, e1, ctx), ctx.mkInt(events.size()))));
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.edge(processName, e1, e2, ctx),
                                                ctx.mkLt(Utils.intVar(processName, e1, ctx), Utils.intVar(processName, e2, ctx))));
                enc = ctx.mkAnd(enc, ctx.mkImplies(ctx.mkAnd(e1.executes(ctx), e2.executes(ctx)),
                                        ctx.mkImplies(ctx.mkLt(Utils.intVar(processName, e1, ctx), Utils.intVar(processName, e2, ctx)),
                                            Utils.edge(processName, e1, e2, ctx))));
                if(e1 != e2) {
                    enc = ctx.mkAnd(enc, ctx.mkImplies(ctx.mkAnd(e1.executes(ctx), e2.executes(ctx)),
                            ctx.mkNot(ctx.mkEq(Utils.intVar(processName, e1, ctx), Utils.intVar(processName, e2, ctx)))));
                    enc = ctx.mkAnd(enc, ctx.mkImplies(ctx.mkAnd(e1.executes(ctx), e2.executes(ctx)),
                                            ctx.mkOr(Utils.edge(processName, e1, e2, ctx), Utils.edge(processName, e2, e1, ctx))));
                }
            }
        }
        return enc;
    }

    public static BoolExpr satAcyclic(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            enc = ctx.mkAnd(enc, ctx.mkImplies(e1.executes(ctx), ctx.mkGt(Utils.intVar(processName, e1, ctx), ctx.mkInt(0))));
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.edge(processName, e1, e2, ctx), ctx.mkLt(Utils.intVar(processName, e1, ctx), Utils.intVar(processName, e2, ctx))));
            }
        }
        return enc;
    }

    public static BoolExpr satCycle(String processName, Set<Event> events, Context ctx) {
        BoolExpr oneEventInCycle = ctx.mkFalse();
        for(Event e : events) {
            oneEventInCycle = ctx.mkOr(oneEventInCycle, Utils.cycleVar(processName, e, ctx));
        }
        return oneEventInCycle;
    }

    public static BoolExpr satCycleDef(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            Set<BoolExpr> source = new HashSet<BoolExpr>();
            Set<BoolExpr> target = new HashSet<BoolExpr>();
            for(Event e2 : events) {
                    source.add(Utils.cycleEdge(processName, e1, e2, ctx));
                    target.add(Utils.cycleEdge(processName, e2, e1, ctx));
                    enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.cycleEdge(processName, e1, e2, ctx),
                            ctx.mkAnd(e1.executes(ctx), e2.executes(ctx), Utils.edge(processName, e1, e2, ctx), Utils.cycleVar(processName, e1, ctx), Utils.cycleVar(processName, e2, ctx))));
                }
            enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.cycleVar(processName, e1, ctx), ctx.mkAnd(encodeEO(source, ctx), encodeEO(target, ctx))));
            }
        return enc;
    }

    public static BoolExpr satTransFixPoint(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        int bound = (int) (Math.ceil(Math.log(events.size())) + 1);
        for(Event e1 : events) {
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(String.format("%s0", processName), e1, e2, ctx), Utils.edge(processName, e1, e2, ctx)));
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(String.format("%s^+", processName), e1, e2, ctx),
                                            Utils.edge(String.format("%s%s", processName, bound), e1, e2, ctx)));
            }
        }
        for (int i : IntStream.range(0, bound).toArray()) {
            for(Event e1 : events) {
                for(Event e2 : events) {
                    BoolExpr orClause = ctx.mkFalse();
                    for(Event e3 : events) {
                        orClause = ctx.mkOr(orClause, ctx.mkAnd(Utils.edge(String.format("%s%s", processName, i), e1, e3, ctx),
                                                                Utils.edge(String.format("%s%s", processName, i), e3, e2, ctx)));
                    }
                    enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(String.format("%s%s", processName, i+1), e1, e2, ctx), ctx.mkOr(Utils.edge(processName, e1, e2, ctx), orClause)));
                }
            }
        }
        return enc;
    }

    public static BoolExpr satTransIDL(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e1 : events) {
            for(Event e2 : events) {
                BoolExpr orClause = ctx.mkFalse();
                for(Event e3 : events) {
                    orClause = ctx.mkOr(orClause, ctx.mkAnd(Utils.edge(String.format("%s^+", processName), e1, e3, ctx), Utils.edge(String.format("%s^+", processName), e3, e2, ctx),
                                ctx.mkGt(Utils.intCount(String.format("(%s^+;%s^+)", processName, processName),e1,e2, ctx), Utils.intCount(String.format("%s^+", processName),e1,e3, ctx)),
                                ctx.mkGt(Utils.intCount(String.format("(%s^+;%s^+)", processName, processName),e1,e2, ctx), Utils.intCount(String.format("%s^+", processName),e3,e2, ctx))));
                }
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(String.format("(%s^+;%s^+)", processName, processName), e1, e2, ctx), orClause));
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(String.format("%s^+", processName),e1,e2, ctx), ctx.mkOr(
                        ctx.mkAnd(Utils.edge(processName,e1,e2, ctx), ctx.mkGt(Utils.intCount(String.format("%s^+", processName),e1,e2, ctx), Utils.intCount(processName,e1,e2, ctx))),
                        ctx.mkAnd(Utils.edge(String.format("(%s^+;%s^+)", processName, processName),e1,e2, ctx), ctx.mkGt(Utils.intCount(String.format("%s^+", processName),e1,e2, ctx), Utils.intCount(String.format("(%s^+;%s^+)", processName, processName),e1,e2, ctx))))));

            }
        }
        return enc;
    }

    public static BoolExpr encodeEO(Set<BoolExpr> set, Context ctx) {
        BoolExpr enc = ctx.mkFalse();
        for(BoolExpr exp : set) {
            BoolExpr thisYesOthersNot = exp;
            for(BoolExpr x : set.stream().filter(x -> x != exp).collect(Collectors.toSet())) {
                thisYesOthersNot = ctx.mkAnd(thisYesOthersNot, ctx.mkNot(x));
            }
            enc = ctx.mkOr(enc, thisYesOthersNot);
        }
        return enc;
    }

    public static BoolExpr encodeALO(Set<BoolExpr> set, Context ctx) {
        BoolExpr enc = ctx.mkFalse();
        for(BoolExpr exp : set) {
            enc = ctx.mkOr(enc, exp);
        }
        return enc;
    }

    public static BoolExpr satTransRef(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = satTransFixPoint(processName, events, ctx);
        enc = ctx.mkAnd(enc, satUnion(String.format("(%s)*", processName), "id", String.format("%s^+", processName), events, ctx));
        return enc;
    }

    public static BoolExpr satTransRefIDL(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = satTransIDL(processName, events, ctx);
        enc = ctx.mkAnd(enc, satUnion(String.format("(%s)*", processName), "id", String.format("%s^+", processName), events, ctx));
        return enc;
    }

    public static BoolExpr satTransRef2(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e : events) {
            enc = ctx.mkAnd(enc, Utils.edge(String.format("(%s)", processName), e, e, ctx));
        }
        for(Event e1 : events) {
            for(Event e2 : events) {
                enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.edge(processName, e1, e2, ctx), Utils.edge(String.format("(%s)*", processName), e1, e2, ctx)));
                BoolExpr orClause = ctx.mkFalse();
                for(Event e3 : events) {
                    orClause = ctx.mkOr(orClause, ctx.mkAnd(Utils.edge(String.format("(%s)*", processName), e1, e3, ctx), Utils.edge(String.format("(%s)*", processName), e3, e2, ctx)));
                }
                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge(String.format("(%s)*", processName), e1, e2, ctx), orClause));
            }
        }
        return enc;
    }

    public static BoolExpr satIrref(String processName, Set<Event> events, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        for(Event e : events){
            enc = ctx.mkAnd(enc, ctx.mkNot(Utils.edge(processName, e, e, ctx)));
        }
        return enc;
    }

    public static BoolExpr encodeCommonExecutions(Programme p1, Programme p2, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        Set<Event> lEventsP1 = p1.getEvents().stream().filter(e -> e instanceof MemEvent | e instanceof Local).collect(Collectors.toSet());
        Set<Event> lEventsP2 = p2.getEvents().stream().filter(e -> e instanceof MemEvent | e instanceof Local).collect(Collectors.toSet());
        Set<Event> rEventsP1 = p1.getEvents().stream().filter(e -> e instanceof Load).collect(Collectors.toSet());
        Set<Event> wEventsP1 = p1.getEvents().stream().filter(e -> e instanceof Store || e instanceof Init).collect(Collectors.toSet());
        Set<Event> rEventsP2 = p2.getEvents().stream().filter(e -> e instanceof Load).collect(Collectors.toSet());
        Set<Event> wEventsP2 = p2.getEvents().stream().filter(e -> e instanceof Store || e instanceof Init).collect(Collectors.toSet());
        for(Event e1 : lEventsP1) {
            for(Event e2 : lEventsP2) {
                if(e1.getHLId().equals(e2.getHLId())) {
                    enc = ctx.mkAnd(enc, ctx.mkEq(e1.executes(ctx), e2.executes(ctx)));
                }
            }
        }
        for(Event r1 : rEventsP1) {
            for(Event r2 : rEventsP2) {
                if(r1.getHLId().equals(r2.getHLId())) {
                    for(Event w1 : wEventsP1) {
                        for(Event w2 : wEventsP2) {
                            if(r1.getLoc() != w1.getLoc()) {continue;}
                            if(r2.getLoc() != w2.getLoc()) {continue;}
                            if(w1.getHLId().equals(w2.getHLId())) {
                                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge("rf", w1, r1, ctx), Utils.edge("rf", w2, r2, ctx)));
                            }
                        }
                    }
                }
            }
        }
        for(Event w1P1 : wEventsP1) {
            for(Event w1P2 : wEventsP2) {
                if(w1P1.getHLId().equals(w1P2.getHLId())) {
                    for(Event w2P1 : wEventsP1) {
                        for(Event w2P2 : wEventsP2) {
                            if(w1P1.getLoc() != w2P1.getLoc()) {continue;}
                            if(w1P1.getLoc() != w2P2.getLoc()) {continue;}
                            if(w1P1 == w2P1 | w1P2 == w2P2) {continue;}
                            if(w2P1.getHLId().equals(w2P2.getHLId())) {
                                enc = ctx.mkAnd(enc, ctx.mkEq(Utils.edge("co", w1P1, w2P1, ctx), Utils.edge("co", w1P2, w2P2, ctx)));
                            }
                        }
                    }
                }
            }
        }
        return enc;
    }

    public static BoolExpr encodePreserveFences(Programme p1, Programme p2, Context ctx) {
        BoolExpr enc = ctx.mkTrue();
        Set<Event> memEventsP1 = p1.getEvents().stream().filter(e -> e instanceof MemEvent).collect(Collectors.toSet());
        Set<Event> memEventsP2 = p2.getEvents().stream().filter(e -> e instanceof MemEvent).collect(Collectors.toSet());
        for(Event e1P1 : memEventsP1) {
            for(Event e1P2 : memEventsP2) {
                if(e1P1.getHLId().equals(e1P2.getHLId())) {
                    for(Event e2P1 : memEventsP1) {
                        for(Event e2P2 : memEventsP2) {
                            if(e1P1.getMainThread() != e2P1.getMainThread()) {continue;}
                            if(e1P2.getMainThread() != e2P2.getMainThread()) {continue;}
                            if(e1P1.getEId() >= e2P1.getEId() | e1P2.getEId() >= e2P2.getEId()) {continue;}
                            if(e2P1.getHLId().equals(e2P2.getHLId())) {
                                enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.edge("sync", e1P1, e2P1, ctx), Utils.edge("sync", e1P2, e2P2, ctx)));
                                enc = ctx.mkAnd(enc, ctx.mkImplies(Utils.edge("lwsync", e1P1, e2P1, ctx), ctx.mkOr(Utils.edge("lwsync", e1P2, e2P2, ctx), Utils.edge("sync", e1P2, e2P2, ctx))));
                            }
                        }
                    }
                }
            }
        }
        return enc;
    }

    public static BoolExpr encodeReachedState(Programme p, Model model, Context ctx) {
        Set<AbstractMemoryLocation> locs = p.getEvents().stream().filter(e -> e instanceof MemEvent).map(e -> e.getLoc()).collect(Collectors.toSet());
        BoolExpr reachedState = ctx.mkTrue();
        for(AbstractMemoryLocation loc : locs) {
            reachedState = ctx.mkAnd(reachedState, ctx.mkEq(lastValueLoc(loc, ctx), model.getConstInterp(lastValueLoc(loc, ctx))));
        }
        Set<Event> executedEvents = p.getEvents().stream().filter(e -> model.getConstInterp(e.executes(ctx)).isTrue()).collect(Collectors.toSet());
        Set<Register> regs = executedEvents.stream().filter(e -> e instanceof Local | e instanceof Load).map(e -> e.getReg()).collect(Collectors.toSet());
        for(Register reg : regs) {
            reachedState = ctx.mkAnd(reachedState, ctx.mkEq(lastValueReg(reg, ctx), model.getConstInterp(lastValueReg(reg, ctx))));
        }
        return reachedState;
    }
        
        
}