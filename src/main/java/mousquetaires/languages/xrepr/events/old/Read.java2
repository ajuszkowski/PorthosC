package mousquetaires.execution.events.old;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import com.microsoft.z3.*;

import mousquetaires.execution.Processus;
import mousquetaires.execution.events.old.barriers.*;
import mousquetaires.utils.LastModMap;
import mousquetaires.utils.MapSSA;
import mousquetaires.utils.Pair;

public class Read extends MemEvent {

    private Register reg;
    private String memoryOrder;

    public Read(Register reg, Location loc, String memoryOrder) {
        this.reg = reg;
        this.loc = loc;
        this.memoryOrder = memoryOrder;
        this.condLevel = 0;
    }

    public Register getReg() {
        return reg;
    }

    public String toString() {
        return String.format("%s%s = %s.load(%s)", String.join("", Collections.nCopies(condLevel, "  ")), reg, loc, memoryOrder);
    }

    public LastModMap setLastModMap(LastModMap map) {
        this.lastModMap = map;
        LastModMap retMap = map.clone();
        Set<Event> set = new HashSet<Event>();
        set.add(this);
        retMap.put(reg, set);
        return retMap;
    }

    public Read clone() {
        return this;
    }

    public Pair<BoolExpr, MapSSA> encodeDF(MapSSA map, Context ctx) {
        System.out.println(String.format("Check encodeDF for %s", this));
        return null;
    }

    public Processus compile(String target, boolean ctrl, boolean leading) {
        Load ld = new Load(reg, loc);
        ld.setHLId(hashCode());
        ld.condLevel = this.condLevel;

        Mfence.Sync sync = new Mfence.Sync();
        sync.condLevel = this.condLevel;
        Lwsync lwsync = new Lwsync();
        lwsync.condLevel = this.condLevel;
        Ish ish = new Ish();
        ish.condLevel = this.condLevel;

        if(!target.equals("power") && !target.equals("arm")) {
            return ld;
        }
        if(memoryOrder.equals("_rx") || memoryOrder.equals("_na")) {
            return ld;
        }
        if(target.equals("power")) {
            if(memoryOrder.equals("_sc")) {
                if(leading) {
                    return new Seq(sync, new Seq(ld, lwsync));
                }
                else {
                    return new Seq(ld, lwsync);
                }
            }
            if(memoryOrder.equals("_con") || memoryOrder.equals("_acq")) {
                return new Seq(ld, lwsync);
            }
        }
        if(target.equals("arm")) {
            if(memoryOrder.equals("_con") || memoryOrder.equals("_acq") || memoryOrder.equals("_sc")) {
                return new Seq(ld, ish);
            }
        }

        else System.out.println(String.format("Error in the memoryOrder operation type of %s", this));
        return null;
    }

    public Processus optCompile(boolean ctrl, boolean leading) {
        Load ld = new Load(reg, loc);
        ld.setHLId(hashCode());
        ld.condLevel = this.condLevel;

        Mfence.Sync sync = new OptSync();
        sync.condLevel = this.condLevel;
        Lwsync lwsync = new OptLwsync();
        lwsync.condLevel = this.condLevel;

        if(memoryOrder.equals("_sc")) {
            if(leading) {
                return new Seq(sync, new Seq(ld, lwsync));
            }
            else {
                return new Seq(ld, lwsync);
            }
        }
        if(memoryOrder.equals("_rx") || memoryOrder.equals("_na")) {
            return ld;
        }
        if(memoryOrder.equals("_con") || memoryOrder.equals("_acq")) {
            return new Seq(ld, lwsync);
        }
        else System.out.println(String.format("Error in the memoryOrder operation type of %s", this));
        return null;
    }

    public Processus allCompile() {
        Load ld = new Load(reg, loc);
        ld.setHLId(hashCode());
        ld.condLevel = this.condLevel;
        OptSync os = new OptSync();
        os.condLevel = condLevel;
        OptLwsync olws = new OptLwsync();
        olws.condLevel = condLevel;
        return new Seq(os, new Seq(olws, ld));
    }
}