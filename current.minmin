
postfixExpression
    :   primaryExpression
    |   postfixExpression LeftBracket expression RightBracket //indexer
    |   postfixExpression LeftParen argumentExpressionList? RightParen //func invocation
    |   postfixExpression (Dot | Arrow) Identifier //member access
    |   postfixExpression (PlusPlus | MinusMinus)  //increment/decrement
    ;

argumentExpressionList
    :   assignmentExpression
    |   argumentExpressionList ',' assignmentExpression
    ;

unaryExpression
    :   postfixExpression
    |   (PlusPlus | MinusMinus) unaryExpression
    |   (And | Asterisk | Plus | Minus | Tilde | Not) unaryExpression
    //|   'sizeof' unaryExpression
    ;

assignmentExpression
    :   unaryExpression
    |   postfixExpression
        (   Equal
        |   MultiplyAssign
        |   DivideAssign
        |   ModuloAssign
        |   PlusAssign
        |   MinusAssign
        |   LeftShiftAssign
        |   RightShiftAssign
        |   AndAssign
        |   XorAssign
        |   OrAssign
        )
        unaryExpression
    ;

constantExpression
    :   primaryExpression
    ;

expression
    :   LeftParen expression RightParen
    |   assignmentExpression
    ;

// Declarations: --

// my:
declaration
    :   typeDeclaration initDeclaratorList ';'
    ;

typeDeclaration
    :   declarationSpecifier* typeDeclarator
    ;

typeDeclarator
    :   LeftParen typeDeclarator RightParen
    |   typeDeclarator Asterisk // Pointer // todo:support more complex pointer cases is necessary
    |   primitiveTypeDeclarator
    |   typedefName
    |   atomicTypeDeclarator
    ;

declarationSpecifier
    :   storageClassSpecifier
    |   typeSpecifier
    |   typeQualifier
    ;

initDeclaratorList
    :   initDeclarator
    |   initDeclaratorList ',' initDeclarator
    ;

initDeclarator
    :   directDeclarator
    |   directDeclarator '=' initializer
    ;

storageClassSpecifier
    :   Typedef
    |   Extern
    |   Static
    |   ThreadLocal
    |   Auto
    |   Register
    ;

typeSpecifier
    :   primitiveTypeSpecifier
    ;

atomicTypeDeclarator
    :   '_Atomic' '(' typeDeclaration ')'
    |   '_Atomic' typeDeclaration
    ;

typeQualifier
    :   Const
    |   Restrict
    |   Volatile
    |   Atomic
    ;

directDeclarator
    :   variableName
    ;

primitiveTypeDeclarator
    :   primitiveTypeKeyword
    ;

primitiveTypeSpecifier
    :   Signed
    |   Unsigned
    ;

primitiveTypeKeyword
    :   Void
    |   Char
    |   Short Int?
    |   Short Short Int?
    |   Int
    |   Long Int?
    |   Long Long Int?
    |   Float
    |   Double
    |   Long Double
    |   Bool
    |   Auto
    ;

parameterList
    :   parameterDeclaration
    |   parameterList ',' parameterDeclaration
    ;

// also my:
parameterDeclaration
    :   typeDeclaration directDeclarator
    ;

typedefName
    :   Identifier
    ;

initializer
    :   unaryExpression
    ;

// Statement: ==

statement
    :   labeledStatement
    |   compoundStatement
    |   expressionStatement
    |   selectionStatement
    |   iterationStatement
    |   jumpStatement
    ;

labeledStatement
    :   Identifier ':' statement
    |   Case constantExpression ':' statement
    |   Default ':' statement
    ;

compoundStatement
    :   LeftBrace blockItem* RightBrace
    ;

blockItem
    :   declaration
    |   statement
    ;

expressionStatement
    :   expression? ';'
    ;

selectionStatement
    :   If '(' expression ')' statement (Else elseStatement)?
    |   Switch '(' expression ')' statement
    ;

elseStatement
    :   statement
    ;

iterationStatement
    :   While '(' expression ')' statement
    |   Do statement While '(' expression ')' ';'
    |   For '(' forCondition ')' statement
    ;

forCondition
	:   expression? ';' forExpression1? ';' forExpression2?
	|   declaration     forExpression1? ';' forExpression2?
	;

forExpression1
    :   expression
    ;

forExpression2
    :   expression
    ;

jumpStatement
    :   Goto Identifier ';'
    |   Continue ';'
    |   Break ';'
    |   Return expression? ';'
    ;
