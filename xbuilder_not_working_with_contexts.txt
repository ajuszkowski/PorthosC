package mousquetaires.languages.syntax.xgraph.processes;

import com.google.common.collect.ImmutableList;
import mousquetaires.languages.syntax.xgraph.events.XEvent;
import mousquetaires.languages.syntax.xgraph.events.XFakeEvent;
import mousquetaires.languages.syntax.xgraph.events.computation.*;
import mousquetaires.languages.syntax.xgraph.events.controlflow.XBranchingEvent;
import mousquetaires.languages.syntax.xgraph.events.memory.*;
import mousquetaires.languages.syntax.xgraph.memories.*;
import mousquetaires.languages.visitors.xgraph.XgraphVisitorBase;
import mousquetaires.utils.exceptions.xgraph.XCompilationError;
import mousquetaires.utils.patterns.Builder;

import java.util.HashMap;
import java.util.Stack;


public class XProcessBuilder extends Builder<XProcess> {

    private final String processId;
    //private final ImmutableList.Builder<XLocalMemoryEvent> localMemoryEvents;
    //private final ImmutableList.Builder<XSharedMemoryEvent> sharedMemoryEvents;
    //private final ImmutableList.Builder<XComputationEvent> computationEvents;
    //private final ImmutableList.Builder<XBranchingEvent> branchingEvents;
    private final ImmutableList.Builder<XEvent> events;

    //private final ImmutableMap.Builder<XEvent, XEvent> jumpsMap;
    private final HashMap<XEvent, XEvent> nextMap;
    private final HashMap<XEvent, XEvent> jumpsMap;
    private final HashMap<XBranchingEvent, XEvent> alternativeJumpsMap;

    private final Stack<XComputationEvent> loopEntryNodesStack;
    private final Stack<Context> contextStack;
    private XEvent currentEvent;

    private final XMemoryManager memoryManager;

    public XProcessBuilder(String processId, XMemoryManager memoryManager) {
        this.memoryManager = memoryManager;

        this.processId = processId;
        //this.localMemoryEvents = new ImmutableList.Builder<>();
        //this.sharedMemoryEvents = new ImmutableList.Builder<>();
        //this.computationEvents = new ImmutableList.Builder<>();
        //this.branchingEvents = new ImmutableList.Builder<>();
        this.events = new ImmutableList.Builder<>();

        contextStack = new Stack<>();
        nextMap = new HashMap<>();
        jumpsMap = new HashMap<>();
        alternativeJumpsMap = new HashMap<>();
        loopConditionsStack = new Stack<>();
    }

    @Override
    public XProcess build() {
        return new XProcess(this);
    }

    // --

    public String getProcessId() {
        return processId;
    }

    // --

    public XRegister copyToLocalMemory(XLocation shared) {
        XRegister tempLocal = memoryManager.newLocalMemoryUnit();
        emitMemoryEvent(tempLocal, shared);
        return tempLocal;
    }

    public XRegister copyToLocalMemoryIfNecessary(XMemoryUnit sharedOrLocal) {
        if (sharedOrLocal instanceof XLocation) {
            copyToLocalMemory((XLocation) sharedOrLocal);
        }
        else if (sharedOrLocal instanceof XRegister) {
            return (XRegister) sharedOrLocal;
        }
        throw new IllegalArgumentException(sharedOrLocal.getClass().getName());
    }

    // --

    public XComputationEvent emitComputationEvent(XLocalMemoryUnit operand) {
        XComputationEvent event = new XNullaryComputationEvent(newEventInfo(), operand);
        processEvent(event, computationEvents);
        return event;
    }

    //public XComputationEvent emitComputationEvent(XRegister operand) {
    //    return emitUnaryComputationEvent(operand);
    //}
    //
    //public XComputationEvent emitComputationEvent(XConstant operand) {
    //    return emitUnaryComputationEvent(operand);
    //}

    public XComputationEvent emitComputationEvent(XOperator operator, XLocalMemoryUnit operand) {
        XComputationEvent event = new XUnaryOperationEvent(newEventInfo(), operator, operand);
        processEvent(event, computationEvents);
        return event;
    }


    public XComputationEvent emitComputationEvent(XOperator operator, XLocalMemoryUnit firstOperand, XLocalMemoryUnit secondOperand) {
        XComputationEvent event = new XBinaryOperationEvent(newEventInfo(), operator, firstOperand, secondOperand);
        processEvent(event, computationEvents);
        return event;
    }

    // --

    public XLocalMemoryEvent emitMemoryEvent(XLocalMemoryUnit destination, XLocalMemoryUnit source) {
        XRegisterMemoryEvent event = new XRegisterMemoryEvent(newEventInfo(), destination, source);
        processEvent(event, localMemoryEvents);
        return event;
    }

    public XSharedMemoryEvent emitMemoryEvent(XLocalMemoryUnit destination, XSharedMemoryUnit source) {
        XLoadMemoryEvent event = new XLoadMemoryEvent(newEventInfo(), destination, source);
        processEvent(event, sharedMemoryEvents);
        return event;
    }

    public XSharedMemoryEvent emitMemoryEvent(XSharedMemoryUnit destination, XLocalMemoryUnit source) {
        XStoreMemoryEvent event = new XStoreMemoryEvent(newEventInfo(), destination, source);
        processEvent(event, sharedMemoryEvents);
        return event;
    }


    //methodCall

    // --

    public BranchingContext startBranchingDefinition(XComputationEvent condition) {
        //XEvent currentNode = currentContext().getLastNode();
        //XLocalMemoryUnit condition;
        //if (currentNode instanceof XMemoryEvent) {
        //    XMemoryEvent memoryEvent = (XMemoryEvent) currentNode;
        //    XMemoryUnit destination = memoryEvent.getDestination();
        //    condition = copyToLocalMemoryIfNecessary(destination);
        //}
        //else { //if (currentNode instanceof )
        //    throw new XCompilationError("invalid state: cannot start branching definition ");
        //}
        XBranchingEvent branchingEvent = new XBranchingEvent(newEventInfo(), condition);
        BranchingContext branchingContext = new BranchingContext(branchingEvent);
        contextStack.push(branchingContext);
        return branchingContext;
    }

    //public void startTrueBranchDefinition() {
    //    currentContextAsBranching().startTrueBranch();
    //}
    //public void finishTrueBranchDefinition() {
    //    currentContextAsBranching().finishTrueBranch();
    //}
    //
    //public void startFalseBranchDefinition() {
    //    currentContextAsBranching().startFalseBranch();
    //}
    //public void finishFalseBranchDefinition() {
    //    currentContextAsBranching().finishFalseBranch();
    //}

    public XBranchingEvent finishBranchingDefinition() {
        BranchingContext branchingContext = (BranchingContext) contextStack.pop();
        branchingContext.finish();
        //Context newContext = contextStack.peek();
        //newContext
        return branchingContext.getEntryNode();
    }


    // ==

    public Context currentContext() {
        return contextStack.peek();
    }

    public LinearContext currentContextAsLinear() {
        return (LinearContext) contextStack.peek();
    }

    public BranchingContext currentContextAsBranching() {
        return (BranchingContext) contextStack.peek();
    }

    public LoopContext currentContextAsLoop() {
        return (LoopContext) contextStack.peek();
    }

    private XEventInfo newEventInfo() {
        return new XEventInfo(getProcessId());
    }

    // =================================================================================================================

    public class LoopContext extends BranchingContext {
        private int mode = -1; //-1: none, 1: body
        LoopContext(XBranchingEvent entryNode) {
            super(entryNode);
        }

        public void startBody() {
            mode = 1;
        }
        
    }

    public class BranchingContext extends LinearContext {

        protected XEvent alternativeLastNode;
        private int mode = -1; // -1: none, 0: false branch, 1: true branch

        public BranchingContext(XBranchingEvent entryNode) {
            super(entryNode);
        }

        public void startTrueBranch() {
            //if (lastTrueEvent != null) {
            //    throw new XCompilationError("already defined true-branch");
            //}
            mode = 1;
        }

        public void finishTrueBranch() {
            nextMap.put(currentEvent, getLastNode());
            lastNode = currentEvent;
        }

        public void startFalseBranch() {
            //if (lastTrueEvent == null) {
            //    throw new XCompilationError("attempt to start false-branch definition without defining the true-branch");
            //}
            mode = 0;
        }

        public void finishFalseBranch() {
            nextMap.put(currentEvent, getLastNode());
            alternativeLastNode = currentEvent;
        }

        @Override
        public XBranchingEvent getEntryNode() {
            return (XBranchingEvent) super.getEntryNode();
        }

        public XEvent getAlternativeLastNode() {
            return alternativeLastNode;
        }

        @Override
        protected void processNextEvent(XEvent event) {
            if (mode == 1) {
                jumpsMap.put(getEntryNode(), event);
                //firstTrueEvent = event;
            }
            else if (mode == 0) {
                alternativeJumpsMap.put(getEntryNode(), event);
                //firstFalseEvent = event;
            }
            mode = -1;
            super.processNextEvent(event);
        }
    }

    public class LinearContext extends XgraphVisitorBase<XEvent> implements Context {
        private XEvent entryNode;

        protected XEvent lastNode;

        public LinearContext(XEvent entryNode) {
            this.entryNode = entryNode;
            processNextEvent(entryNode); //todo: dont do this implicitly
        }

        @Override
        public XEvent getEntryNode() {
            return entryNode;
        }

        @Override
        public XEvent getLastNode() {
            return lastNode;
        }

        @Override
        public void finish() {
            //currentEvent = getLastNode();
            lastNode = currentEvent;
        }

        @Override
        public XEvent processNext(XEvent event) {
            return event.accept(this);
        }

        @Override
        public XEvent visit(XLocalMemoryEvent event) {
            processNextEvent(event);
            return event;
        }

        @Override
        protected XEvent visit(XSharedMemoryEvent event) {
            processNextEvent(event);
            return event;
        }

        @Override
        public XEvent visit(XNullaryComputationEvent event) {
            return visitComputationEvent(event);
        }

        @Override
        public XEvent visit(XUnaryOperationEvent event) {
            return visitComputationEvent(event);
        }

        @Override
        public XEvent visit(XBinaryOperationEvent event) {
            return visitComputationEvent(event);
        }

        @Override
        public XEvent visit(XBranchingEvent event) {
            updateCurrentEvent(event);
            return event;
        }

        private XEvent visitComputationEvent(XComputationEvent event) {
            processNextEvent(event);
            return event;
        }

        protected void processNextEvent(XEvent event) {
            add(event, events);
            updateCurrentEvent(event);
        }

        private void updateCurrentEvent(XEvent event) {
            currentEvent = event;
            lastNode = event;
            //if (entryNode == null) {
            //    entryNode = currentEvent;
            //}
        }
    }

    public interface Context {
        XEvent processNext(XEvent event);
        XEvent getEntryNode();
        XEvent getLastNode();
        void finish();
    }

}
