== Meeting 3.01.2018

1. no loops
2. ssa: phi node -- merging the branching
3. in final internal graph - separate cfg and memory model graphs
4. mem model действует only for shared var
5. approx of determining local vars: if any takes its address (&) then it's shared. (there are other papers on this problem, see escape analysis)
6. add in current porthos: set of events E={e1,e2,e3}, relations A={(e1,e2)}, B={(e2,e3)}, then A;B={(e1,e3)}. Instead of this, we write large formula ((e1,e2)/\(e2,e3) -> (e1,e3)) /\ ((e1,e3)/\(e3,e1)) -> (e1,e1), ... . You go through all potenial pairs of A & B: (e1,e1)  ==> it's the exponent, we'll need optimisations. todo: read about composition.
7. by week 15-19 the interpreter part should be ready, with tests!

next meeting: mon 8.01 10:00
questions:
1) is C11 a subset of C++11?
2) using llvm parser: still we convert c-subset code to llvm-subset, maybe it's more reasonable to use llvm directly?
	+ very powerful -> highly scalable for future
	+ problem of writing parser C to internal and internal to event -> parse C to llvm and llvm to event.
	- very complicated code and C++. but much of it is already written.
3) if not using llvm code, I want to try scala parser (same as grammar)
4) TYPES: already primitives. structures, enums -- non-primitive types


i try to stop myself when doing more than small c subset.
i understand that we don't need the production-level code, it will still not working because of the exponent.
	therefore i'm orienting to kernel-level compilicity of c language
	plus, if we use llvm, we won't need the c parser at all
i try to write the code so that i won't be ashamed for it in future.
i try to write scalable code, but sometimes it's hard (i changed the grammar).



== Meeting 8.01
1. now - no optimisations in smt, adding them is non-trivial.
2. what we'll need is to map asm level state to high level code
3. not for me: research optimisations, 
4. should be done: compilation from asm to smt (easy), hard part: comparison, how the registers correspond to locals/globals.
5. if mapping from 3. exist, find a mapping from asm to c
6. we are allowed to do minor simplifacations, but log it
	gotos: add goto to AST 
7. by default: integer theory. only integers and booleans (floats are very hard to encode), but as a parameter if user insists - use bitvectors. Check if SMT has float.  
8. poniters, arrays and structs - later; Z3 has array theories. Firstly: pointer as array of size 1. then implement pointer arithmetic
9. Pointers: we might need to do some alias analysis. But for now, we may do encoding by assuming that there's no aliases (no two pointers point to same memory).
10. Find appropriate simple code excrepts of kernel.
most of the problems - any symbolic exec tool faces. take a look at SAGE by microsft

z3 array theory http://fmv.jku.at/rerise14/rerise14-smt-slides-1.pdf
C32SAT: Checking C Expressions http://fmv.jku.at/papers/brummayerbiere-cav07.pdf

next meeting: Mon 15.01 13:00

--
Notes:
- I'm doing SSA on the level of xrepr (events): on ytree level must be only shared/local variables (separate analysis stage after parsing to YTree), on xrepr level must be 'register' and 'location', without SSA form -- those who are directly encoded to smt formula. The SSA will be done as one of the analysis stage on the level of xrepr after parsing to xrepr before smt encoding.
- On xrepr level, I operate not registry and location, but XLocalStorage and XSharedStorage.

Questions:
- Is assembly level still enough? e.g. 'mov eax, 1' -- here '1' is also stored in some register. TODO: check if these operations are memoryOrder so that we can model events in assembly level.


== meeting Monday 15.01.2018
1) lcr programs - EACH line has only one assignment to shared vars.
2) figure out the min set of nodes in event repr
3) THINK about loop unrolling (but firstly no loops in programs)
4) we'll need fences in the event level, impl as interrupters (type processors)
5) see kernel parallelisation in boot procedure . TODO: see presentation of 'black' slides (Linux Kernel Memory Ordering , by Paul McKenney). See his 'litmus' repository on github -- additional litmus tests, test generator. Google: "SMP Scalability Papers", link #2.
6) Out tool -- do things in Herd way, so that its users can easily adapt.
7) start writing on what are wmm, why are they interesting
8) aalto into : latex template, aalto msters thesis at aaltodoc

next meeting:  22 Jan, 13:00

==
